<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d7373ee5b36ccda072e13819a4903ac43fbe21c2fb7710b54f6cda533192b1b2f75b6be37c4a53819624291acb7ecdf90da74975bbf10912e875a8a43789ead5dc4bd31b682a5aab813d487971c5bad378ef240c8e8306d13d365efffbb6b483b3080858106ace305f5dfbd0c40e0ecbd6b8e482546e09f0e91710d44c6972ac7ff340f7a8edddb38cf8ee1cd6c0cd2fa8dfe19d91e10d33c123784dccb18b1f15b1250a0868981a31807644de53277bdc6a911437318047759a9f6556f8a23d1c1f26dd4e6e47d2375f1b1afc7673e5ff217ddc81ba5b1aa339edbe1b8f915b0a365a43cee5afeadef17ded366c4a32116f00108fe70649fe2bafc89c13e78520eb15bb79b9a72e5f89f715d488b2e92aa8368a50977d573b8ebd7be8038422f71e3036f15b2de7bdfc033e81000dca672e56d7124a95c56e4350597c9bdda8a0fb8157a4979f46b9685f642cc6c4d74674e3c19e4acbb7366e7e04a8b5d5d03d1ee24c1caa70d24f6750d65f66f1d7d3b539d54b0c54cf63ee91f38a9519b0c6badff487ed35af6b22bda211023af654f221cced3ac3820866434c934630ec78e40e77985c072747eb9cb164a2487fc41adfd632fab6911f47738bf9a537074dd11fa0a1001dce310cadb306c353d25c8d54015cfcf1e4d9eb7f1abbfaa692f8c5419973137f0675262c35f0f4c55d7a84582fa3b86f93a225053102475ae5f308a6b7a2ab36a411ea884749dc645ee67651d051b2d5fa9b8c2254fdff5f42eee2b075a6ca03ab08ea79f5f66a93be270df28adc87fe10a25c012bfc2666708fc68c4b55768f2d802bd33c3e0a70245828e748aac90b04a2ecdcfca4015d9ac773869e033a66b3e03ea64afd81772a2fff0084907e8477fdfa2c73e152da1095005a2796972d3f35007a619b2fc041acfaa308af0e6375a5fd0320a7f0ba098cc2585c8cf3c8c08921116c066a91049eec7ed06fafd45f4a32232473189c03e9337a4483b84317bb1358ca4ca96d3bf1305440591926fc6b46b2622d86f534c4b11a52ed55951c000bb19a0fe52da9a3170b1ca01d11ed7242f3a0315712b3cab6c2f5696dde167af31cf43fbfa7010faf88afa4bd1f92bf60461beca651c68f2d06ba656ba23f7ba4776224adcfe96d23f35629c499b574092135acb0b07b639d090c24a9c60ee1723d8720801a5132d8b3ff6e2d379fce5d4ce4b58d474333c27baaede19d698b2b1dfec011b2e09893dbb55d093128f6453b156d153d8bbc565bd481c1003daf27595c686328adcb5efb1182b3f6c211ed04ceced47bf19c3dc74c5d550d6bf4d22497130382c2139c711a45fa85319bc36c763d1107a260c81675f6492ec12e57e70c61db16b4494c9eaa005adcc826d9d8e65e73d4daf7edec8177c8ad3147f276919c81a3efc66bc6a17b0125e4dc5d3f76c0f1289ffa0b6167cb9592e7e2cbf6c19099e14ed748573c8459e968790cc56d94fbac349e6716078d8b556e80a0154e4a177047bea6837a1666f983f865180bf20d3d284706de0f00057b69dc162e0ff2c4279dddf4b9fa4702cb01f8b4cc35e6ab3f92ab860b2d33c55f0b96d6b922d356cf94767459b240973d01023e7ca1892a84cbae725748d57a231ef6cc98b4c1b7dd72f2332a5d203e92e2b08ef2f46e1f995d0a0d2750034e797354f653c9180e010067fb0043e0023e83081e0a6efa5041899b30e1cd666ad59c673f74fba20d968330249e8f2aa70eed3641866bb898f39fe889019eb3d9d3ee6ec6d0ad11fbcb18ef19b2ded72c9fe2bc70911dc54d6fa6d4858cf352156edd942550cb2b0838b5ec719f318c6a67c5edf727c2431f10baedc14f71957ba6021df32669e1a5801fc0460f367b7725f247e05031ee556896bfe06ee9868c8a6fb823c896f6e56b5b2478a13e54ae2381223bc4aaab37d3eb4924726c76fe84bfcffcddcc4cafa45d0278418678a5bc40711141d4db6712ad860b58bbc2a57cabee508b6fe72bccd878da507f1a18f136588b4359e45519d3302a178ffbf5acd3173d713acbe55f5955edd4925c6d9629d05a7914c67d21b138528c5d44f69ae0ee764dbf75f3194f7e210d30363593a5a3590f319866dadcd23c7e6028f10f3d582374e264b854cf2b1d348d7c3c5f2275899c2ff69c4f3a561c5685d7be16e0d15e824e6d908f4d4a84fe6b14210428e464b67edcf649a08783d1dc858b2c437b018cd502a0cc3f28304ba77db97c50263b9e8e2a8242c86dbfe8c56b7104660d75213f7b2a2b9082bb7c9a2caf08741abdd997324b0306a6be2ddd67d510491f1691d4291c83f4a07a660838be3b2551308b370ec9f2e391f69fecf742c952081849a735f579450a71e6345768b1282d6dbb0e97c51cddacfae8948591f24a9655c7e9f23fa3d2a288ca2b6274cd15f9fe3ed1397d5901ed3ca6ce85e72770210cc46a95369e5bb1bd08b41bfb935b7a675635cc92ddef1a86e0101a8d6406eb613bf7055af632d4a27ef696c5482e76d6c76b48ff159b5daceef3195b51de688eac1f8b0adb2b7f24683ec7df092f07b4c959b8e74f969d0427f15e4e8fbbe66d1aeed838e9a7c7d314cf656381f860d8582e2702b4e0004a0bd97bb92b52ae788995d2f9a2f2a89f8559398db7f81c0c133cde79ed3e8fd444b0e90fab38d334a41d46276a901dbab3957c9d0594419bcee8bd3195686c22de434b6f52e51ce6f108dcd4f33901cbaeb81ace39841ac3976eafe0a9434709c6054728e717d5d895ba4cdfd8371574157f921bdc91559a3c0734071c98907d6680da542374c05d947e51f3714d0ed6da98ea857156e4d2726fc69347b3605c274454d79c9e065792fb63bcd00b6a043546d12a0d876c41668987206619d3cc8c5e8cb3dc82ffddf79d9f5b75fd3a7777265debc20428543ee3a7686750e8d7ad65459a4efc1fbbb19f4273f7f22537def2032b9481f7ade37791d64baa01e91405080b09b4c5f53554d760f0604ed730621e89d2fbac53c6363c47da75fabcbfb0df2f02fb51ce6f8ccae1744da6f9796d1f5910e66ff87ca06fde7910d535865be3e96052387f0b3721fd47783adbf6410645e1681266853d2283305d979c769ade315917be6e3a860847843dc605165482b4bfce7a867e08ae26440b3a949d5491f79290727ca9785dd4b8b894098f587b6ffa93c3b4f8719eb259bd454658149a12bc81eaae21a1a2e8eb72047489cb55ed20d07defcc423f6ae98b61d1716cdac6312e240e0aac1e517569e73404a44a83a3cb0efaaedc2051c7f6071af7ae2e62355d477a4f081f4dd01d00980daadb73e8c9a6a1cccb764534d2760e65d2ebc5f04cf4088d4f0392e82bc4bbb792f06c34d5c28262af775e44e6ed23a6db677fa65993528b375814ce03adc44b2bec7024c175fda24908416f5fe022b4d7eac04e72aab923bf518cdbee6ec100052a4abc076d68a2690fd0b6b0cc1fc7c31cda43d0774cde01cb3d8c1b67b7337627f51904c3f49fa508d965cdf1a122d7cf93f32bb9327b53c580565fefd5b6a897b5a7f3e37a6d097990afe9ae69389c852e02b8cc7f1664a371620e119d0ea1901d58498392b7f84b4f2b93474724e85855c105a97aa4b22841487568984b1913b98e667e4d6a20af4198ffad089e91dea911650addeb02dc9cfe600701a73b6621093d7d6a0d8c3cd6bea67298f261ea6c058e990398a95d796b5bc2e93c727202b15d60366852806a3c8b25eaf2bb6e5ac1109f6fa8b16acea6f807cf5276dc8f3350d9be2ea57d9dd12a1800d7d07d60b4092888601858e101f581565f16fef7aa1b287c502bc421f4a9a0ff2575f27bc85161569e038467aeb17d890df7deb29b9cad80249cfdd905375706f07ab4fe0e0fbbe715994ab40e53cbe897cc815e2d194b5df96210fd21264a754fa0bd05fd42866c6214f516ae44bd02e775250f92a17594bdbc216cd206930d1da9ef748b33adccf7b5430ea7294654ba1150423c8955ed62c353d1dbec8f389d76d68bf5834b3489dcaaf087eada31fe705f15abf51cb2626397655fc920436f92d03c5db2b66d72d4e7c72d99dcca68040fe11eb2a9026620f9c2d13c7623d6cb6d5909ffba5c54beba0e11617fc6ecbc60d1dd9386be4991255164a4dad09c487ade3092591a5950f7d8950f7846973e7bb909044906436db94f31a8408a5db938bab3fff634a8a7a3c861150d79d1780b1392a72e35a7c9cf1ace89d9145f27fdc26405715012430dc955303904deae01af550bccefedf6a01f71804d5a9d0871701697d60bf268ce1600a90733ae861fb37e75c0993b1c983d2b087e5cb072bbff441eba97fc2c979c3b8f94f665fe2cc9c411fbfb83e5664db3544f0bfec12af9351a766308ad46cb8938b41c657eca34cacbb2de0b405b04390abc94d9bbef3a5d9334f406e87be0f1ee3e52b6741824de56bd5b3a6f253ed01bbc78b88e9959395f81cde59e3dab1fc35b420e1edc4a95c7ec3d47ef861acd944e7ece50f40e95966f67b5bc6eed8cf4c1d9813e6053159e933d909123aabca1bdd6ee3af6cabf616ae17430afb42173e44875b93c740fb8205ce62878133e961275b9840fa9a004088ebda40212da1bd4ba19efcb318904755fd141084a2741a2b25780fc94a31144c8b6685eca1209893ad8ab26e4ca13bf01c37b28c449d3708c89f7bee5ebcb62c8cb954359123255a593faafadb0b8180c2f791dec3db005f292c7f374f3659543f3de8970b9263bcb56de985f1db339e96485ce7970088804a660a0a695d31bc8261b6d1412902ed5cb75b01b8093b938b984f5f6ca5e1f29f630bf18bb037436965d18edc7bf1fc1c6f5153dc30951884d7e96e54802b177121a420354b13120e2b84cd1b14168b63ddb943d8f999fb45b116cea37b06a2eae2637411b6e798558746738e10f637500ed755d39629d2ebd64613bc7104e66ab1d492ddd699fb60dffa9adfbd86414e278e28e340614377d6ea5d4ff1e525b0eddc3fde49dc77ad8a38c8989d572e5496c50b1a6edcf7d52cba5e1162f639d51aa1fd599f3e7d34e9ab92bf84d4bff576d8eca716d11406db50993446997ed860c241282fefd5fea95059a469544d630857da662b0b8069a7a6e6d504872eef56c4819f2c94506aebf8968b01f2fdbec4dd913cc000833feb13b87fc926b79ccecb51ba698d3eedc359fd6b34ec4f23b98fba7d3c6dfbecf50bb4d5ec994bc9e7241328dc0b6055b4d7658e7ad3adbb1efea11d56920b1b6bb48127e38e2895f54c5ded9a940dbd7c4a6e1f8fbb9d7bff9aa17e485b67bbd64d55e52b6b7d2fe7042dd7e0c1b00870475772d56ea92d76cf57dec293e54c154b5402e827e2f0e3eb31bb47b7f6a762e14e0608649a8cc240b3ecfa09398722b868eac0ac59d36a0d45fbd8bbc236e307b4f16688f72f82d03a8f03a631c2619b07e8a77d7da5827fb9532130a53d8370889c2e36c6819117347e520ad4e254f0d8b8db71e0889ef8e8f03f6dd71919028fa3549d451378da6e212c87480e9cb19327ddcf542a1bcafdbca000130e4a7ffca754882a1bf387a38d3f729e8444a7ac55d8a5b322ae29e26810ffb3c9011c8d22ef27c90d23fcd00c24d5e90649de2a2d7825edf10bf72ce4c6c107cc4d7abac73c244cdc1cec171a5bb9e1188bff6fbf5522d097036c0a3b1bed7e774cbfc68c64c491fd58dc15b864e124decf0a2a8122bcfc69a05b98f74cdf79b90bf7c07745a37ae1bfea3a9147ba04bb42ae06ca84d1ff28a613ef775dc796d741d0b3deb618f1adf595ef90860963606d38246df25603290f859563156ff7743b97896ad4fb2b165d7b6c5a7c6efee2d597193ce7642d7e2416a412551ad2aa20f7c04608c75600f37695a36bebdb3c3d5d5dac5c269ea60820dac2ac5987a5119064faa8814657182638ae9b4b5ca1650193df5054f5fe34f5411089bf9e29d587ce00171acdd9c426e52f3b80dd67b0c44e27c94dcc0f135d6a1dd570259a5a2bace541bd71312ac0240e2c04cb4748a7e877b2d8f8d6f0312af677e86152b45c371bacf6493b0da56961340ffa2fb172e141ad5f27bf8d37b86a21765e6bcdade4ba8cfce413f8285662e42e6ada076ea4d1c3e8f3cb7eead933c61b49bdebc65d75dc5708dc4badf58629e24010d87ddb7cadeb87e08d296eeeec5fb84ee8158c8271db21ebf134e32ef2d1c258926af99232ed2ef39a7eff1fbb74b301bbf830bf7a23765e28adb1f1050654369efd6153fba93887d41a76bfd07f26b0577cf0f6a6afd6640311580218c9e714822e9a20ce92ee1e5091c6d25f4ef53472027dcc4f1f6dab8708a90fe847f3edc17dc8d2e235a9896185b3450b59684a59b28449927ee460fe356c9c2e7842b12e941f8766b28dfc086159aa2bc7f315e983c38ad0ee2797a951f022d4a3e93931de0f9106a86f692b80307da218ffc9b353d5ac54fdddb6edf01823cb651d6a07a43c4270149fcd32ba7513a60d7520a156cdfec97f7794b5f3eb17e241bd06729ac9f9af5c45a637bc6630ff54f29977a8fd9f711135af2e1b3d334b8c66eec1b921b9d0079a14b0843a105e697e0a7970cfb4bdd0979c76f8f1ac782545a1d7de586c89b997b7543534b9920f7a581b0a360d286fc9b3b68b427b64819b6391d07401ede2caa7706de4e17d513fab24d0342f44b44c5653e3c6da222d523e0b56df61a85958fd9d2495b245633175d014d89548b8b1c1914928f97ba536cdc6ce1ccea0123dab631c54ea49d29ec333cd3cfca4d67243d1f18d51c282ad13e6ef8e18d9f07ed3e28fae863bf197089f95954d2172cdb56dbf731d7c8634a219c24314790f4565d6e10d00e9fe06341d999a39cd4daa3ed18bcb48cd2aed64a5adaa0eab23e1cba867ec1f454b106b1b6d46821b8e91ecef450004c68b02eafb9c33a764d4f18f8cf3e6c1bc6e5fceef3b33fbdd8e0aa220ebc1bf2b659d3f4ce02252c67d6fb69c00d96f0685149cfb149b7bc2abda12dd99537610e51bdcbfdda83bd2a8cac9aa48efc6e2872d95bfaebd2b80a7f3a46e407593a79abbdc5d1c9f84b283cf90024cd94f5852b59d1c6c9857d12d2b2c08be1078a5ff62487330ca547e70ce0affb5a1215f70372f18607244b0b835b294835e554b3eab6b237f0333068393d62dad2c4f3a3361d4059743b3d877c66f9c49ab63b89afaeb9dcd8a4ee1533357c8a56bb833c562096626da1e4828d0f191f243ab2c0c1d0f82c821b258053d5fa2e051319d99b18141fa5c2dbaf9bc97cd81d458c72ecf232a87eb8adf5e52ea2307529520651a97585a38a74f1f2d71a26f0bc2f8ae19accdc25d26c37dec4a5e7cc78cc6ccaa6683b59f0012ba50b63b0c9e150a8dec73a9bd9e96c581c362a6ddb54278f46e865d3e2183716237203c81d5b3cf658e9c1690472d9d33fa27046ecaca9a9cf7d423278bb177e3ca6aa1a87b968457eeaf3875aad2c9a546db517e5d4778d92e1cc18b69ad2d941ca87b0ffd9d76abd07a20e50cafc5b751d7a9421804a0b77533daedd6174d0b85af1767ee600c8d17440a734c4c4e256ea0fc7d31a7fae70799ae37b7ee4ad9f77f1526fcfc0d063df5a4ee593dd88001d356dceda063a103b7cfe05bd79555215b82c3a6a1aa2ef3fe85e4fafca41f6dda5a22cc99196b4e4d37e2b47b96fc7ef9f6d764a0d97bf95fde035fadea160c73476a676bb9c5c1dca6f1a406e7075330ad09876c738cd2e41591b7d46df4e1abfd2ec724350901e0b4d01cd302a80f4580c416ba3607a2c938a39b2a0e7ab1570870aa6feac4070798ba8f8419e48110b6ea99971ba18c4949a8177bd7329bcc43be57a27f5ecffbc5f3a3fbe0f80d1f4a50f9025de11d0aa0cd5f869150365ed2c560018c632a8e3b1061a7ad17ee795c0312ba311be2a67f2ed8aa57de5140a8636ba88b85dd57a2ba4b5578e740f1bf226da47e492770ea804d6c9d86d0dbb0771d21abaeea1de2fdb8c212409619765fac49a201d70cad9a16aed527d3e962d4419793c86c486319686bff9651861f6e082e636d16f94d30ee205c8c12d887ae31bbda484a4d76f0d6e8fcb5e4d2c41f06a704bfea97f83e5f5cb6aafb5573870d99f5a11850430a1ae2f568f4bf3aa6455c1486a20a1f04dde0871cf97c860871abf6c5528d4d4dbc35352c34d4c57bab8345aeb38b8bb8753387657c04b8f44f1b232d30fcef20f7986cc8b103d46d7e7aaf5407e0b7c97b1462b7bcdf84b4e49f3cc51e4e893bbeec9834292981b7b9f49e7d1d7938351db33fa9b1c3b266134f4d70035727aae87932d9644e72f4bad908ceb05295514edec0ecbec85c3edd9dff1431320aff34e325628e721117d683eee8db41b9ae83373397f2b62dfcc843bbf5a40cbbe53af15c973e0d815081380af37b47b8a3b93d76fea0b308fe9c32a0de64c7168c84c69ed5f90d3c52e5c6e388e4cb5c9f2e95af2fc3e1f91e05dc4b195bf2065e56fbac472840a8d70248713657bdfa3d97149b33c8a8a6f8f354fc1f37fd8845f6bc6617de047c0acf56ea1c4321f7dd58ebf773b236de97dbfa3c4ce110deeaf1b42390c82a69ccb23af5b4bdd8374ea7bd301b70992731db9d8012736f24354ddd8e3a518f2ae7cf62e4e685683e9243311a4eaf7221ff51472cc68b5ba5a85741cde8a7831795b1ea42a50d4ca730c88e5e8b994fa8cd1ad4dbee5385c07d95e6246027bbcc6e846f18346f46e098dfd11d9c3d815a189cb0647217330497775ef1d5dc843c466ae83ebc5fd0c442e073c1e89aa0f59a73c71dc7fb024292273549f96077cf518c542180aaac2cbab24e72a100ae10f0711caad9ca92b916b6aa633022a2ee36a6d1cc578b386540f8bccfdba0f069c99bdb5f5d6930b0df9952da3cc50ac89d68e509b8e5827a5640054642fe2e519e1b01b35a8160f694c5bd7e4b1b280f76161fa30d50b45c3ea9b2f17e14beb7c9680153ffb62214d402277a996168c507474a4baef47fe6c831024aadab93de46bcb846d5a9653684349730e1413c1ea83504c615852ff5cf11f338320270a084b91b4ba9ab950ac4a9ae2e41ae9a27b3b516accf9eba6662339eda75e1038e1cc6b42ac7fa5a0aeb5ea926af00ff55f680e7b7f4055e68f4071e2a661ddac8e2db5c20de36bf48f7dd902355098665564d7afbbbc7ec0ef4efc125a00c42e29c100a375494d5b2fc4953908ac89e4acfaf9cb231938dec6a1a1bcbc70577dc1a12247d3f395469c28b74c7fd88c7f7f1aa4cd2114fe90fbccb153c375bf09f98b07eb7aac72854cb7dea49ec2f6b6f03ea2b620360d045b5ff834e3c02875999c3c44372318e284ee87a7c6622b86beffcc130d316d340d8fcc508366e8c97ddb2ca7f0c78211167e11c3806b72d03f1372369bea06ab6fb7f30553f515ab2b1f6124524fb5bb2606ceacc3b147f7342a525d36235bde955bd510863d7882666c05a889856e5accbe02eb156992989bf36a75955149bff2880d76a79f3fa5c79728028c4a9d6b98b88c5901545a3fd51dabf4ffa7fafe6db448e5d4ef27bdadff48045e5ab70493478ac70e61f91426c37ca4614836c435e6d318ea582b4f8da17ad5aad2756d5736a18cc56be4db8a709fbde0558eb92586ef534d2db2f60483575c7f317f6aa3f83a9df822f9b15b79ad8233a3995543002ea9d4bd5e95d4ff818855b915eb4e5fb5955b4e4f01445e2b13944221fdc6bf6552f6fbfe154987b077bb1425c1855f1c25b01d6af2df2ceb98aba86b40fc8d52b370280227835d05d18f8a6a74833cf922bbdc541c2bdd1b9d847f0ea7dee302a2dca6c36eac01cd54034d4a38e8b112252c8e8c6ee7c101f03c8fa245f4bdb1bb66718b95ab968e81862b1c54f2b4d892765d6e3235c0bb7a26c1b6efd7e67eba7b7b5d1903c4edb6e3b8dcb74fee275e65328631b18b92270f9169bcccf8f2076bd6e17a840de45205bfd3572cad9ebdf87d380f546284cbeac6123446ecf74a662e8802e40e4d649e066f932cb0f8695a5a7d6d160b8a3019fe7ed48b60597667c580612cc8f48e7f3e61e2528198a6e121e92119e9bde826b77cc67ea36c78004108d93c35755e59c069b60bc326667fcaeebc10cac181c5aa3852390d00d7c49e37a442e65ee0d2e2c0966d60908132bc8f91514f504cc35ca175dea8ae830894ba95caf3bc4d5e2532e52fc318c4554aa3bfa53e0fc7abab40e03168d818540694ed61e78b9b1656c0a9741eed02a9f11044ad68480b90f80bbc480b4a1aa783e90d63bf94cc7a78e59e6962deb06b6c70e6a833d45241c0d25659c3dc4ec4695f5047310f82103cbd5122361ef36e61ad7f3768000c7ce5fe9bbc78f3c662b03e6df71fb499f9c33c8357fe9ee15d9547e05bc7f6aac1cac64e2a7f16094dc714e22cfd46fe10eb357bfc7f8466224654642978a30afc0616a04e2827a6acc556fba3915474c04cc73814119446f51a639c7ee512fa2c422d794d0514e17585904b6458dbeea848a9f9b6e3c2d74a1084c769525214b6a04cbd466dbfdaeeade77c6052a30e678562c89e65a988096792e8ab85d2c79082710344c4ea4b8c5462d75cecf994c0917ea7b0e05cc3f64d72fdbadb514e02f4638477d5a553739005caff50dec0de61d20797edaf605b8a0d092b1b7c3440a7ee59eebfa3a94f17920435478f4e6376727c89cb810ae3204511f787d9155244a5a7c6e13dec918cd69a7fbb9d8b610187c2f59c81a02f83e0edc40cfff4248cf6ef439be02e98b431ef031ddc5365578e0f3aca0690deea84ee0e08b9958df96a828b57c57c078055d3e623948fef30d97ed7d2fbf8a85e95f7c71bc9699d40b603a58b4d74c2726e0f067bd7789a767b01071cd6612c24d63d4b2e653901a850e9fd79d408e87c65107ab82b781adb121349540d7eb16853164d588e6b29ae5b010605d058de923329c92d08c14e321a3b715ee65c74c50b3c9c0e9228a08b0c9f71e160c2544c1be96c7c5d366b3dd9cc9aab271bc8a437ed743e479a2fbbd0427a2a64c819c1c4fcfcc176fd6f530409b68e4c4fa5b04b78cf15c829c206fc41e7610f81ef8482bb5bbcd417a1564ffd63feb19105bc4384325d1cce2e35b782851c98309cff769bc44cf9930ec3c56ded61f970d0ae74118656ee0f8eb788f9bdf716f3d9d98f1140c21f2227b1127ad2c742ff45c20335461a9e9ca19a319402b366f118973b30cf4d957042a2a9be77bc4cbd12ad714505dcda5f541004065e48c22a1534e38204c55a90dd06b109059ecdbda65e5bfb8151d07f8a7773f0c0fe27a0f98341725f5395afdb6bc1d1fcf74328ac1da15f1e922368d3f132cf2741b01823812b2085fd5de77b8f51574a34c73eb86f99f7f700b475b5deee31dd71ebff59f33c11e161d6ab8dcb497566f6fd3ec9393e601504e1b4aa4ce0622af89f47b44d23b4e7208b472dfc730bf19159a1295e41b0f6c63c44d7b08287058a71234d8675488325fb4fc58d28c25ecb64668ad16dfc14be8ad36dd20943b0aa3437d0d97f399234bbbd46d3e818e45305bee6596ad9a17bc8bdbc9b447832342cb2c6bad95950043135b69ae9c20779532c7e9547908aa4378f196548980cbb7986f4b0e40f160ccf5b9697c60cc43afaaad3d71e9cf3d7b560b4b4cc42a011d5f4f8cf2181479c6fbd135c51bac70e719ace37b79ddecfa71de72192146af59b6f846590ddd803e642c2c1d44bbb3f76eb4b032772f12ccc015b211f810e1327a575ae8d6c0f47b7f14005fe4206a52ad25a1a3c3bc5d7bfcc66e64e50b6d6a9e99d75bc9e0bc95d7febdb4be74b5fc318a23fccdd1fb722a724c702ee934f832a87c4a9fe8f2cd53256ccded15ec5937040abe98955b0b882e9633dc584f620cd7ac5a09a309f104df5403733a8c8197b4b64a81dbcebec8734af502801d0e0459e7ae432d59846d9867f18a28ae9cd3a53cd822e59fa01f61cddafdea26f2eeb2f0725dd0321b13af5f9a088aad0e25296e73612583a1dd18d68a6ad77acaa9b8141d487c6697ee22330efc282c26d6862eb831fa5a8285bbb0aa6d754efa61763cd51936dbe9c651aa59e5b80b89173aa9ad70f2eedccd2f808efe7322232f0d545b5e7d4f86f11b682beba498ade11b693ba7177bd90ea9cc124e9b9f8bc39ee3a60dc5b385f8bcc85c4472b5661d09b82fcbb0e9c57609b18e6e449ab384110c693bce6070ead88d595c591829351525b6a09cc3eb58de45a09732096b564272444ebd321f4377b722e24ba9384b34595632a1392f2cf34f09b898872567aa1fae695f201f8b3e2f559ae9fb0544abe5a87f21e520aac2ee2f00ace1f840ead62c25cdd4dd9af6f1f17bcd3bd45151acc24464036b84f635140db80158c09b2909f909883ef8f9d0281cdc238b6ab32b91a70fb1c1235701cc7730bea18e25861e23ff452e0abab8ffb16450ad0fd6f21eeb6b6b14234c0d1a773312593d9cc3d6e24bc78a62eb515999bda7b363381234c6f834660b4b3e823a6111af540daff92379d609c90e6652f5fe9e344e59effc32947f0a31202b047e9e9f85524056f5fcc2ba90e3a766294f5339dabf1d51eef075afa57f0f13f5c4070eb6454f68100ea30157f94fcf3fda86e8e952463dffc8d51fe828d741eed66b1cb5d175fca9b5dc1f8b06a9debdb626f4b03b33da13e5873c80245f9d531a14e54a191388061cd048d55d528baa3b66653ae2033ffe13044e2feb482dc7c598c0be2b7bb7d14174d9de655402cee8014384b7eea0f19373ef45aa9b16e15ecbb48df4e46683e763a59720a199002594d492b2a7eebe8fe776f8e768b0e821ec70ddd2ec32ecc18daf57b53bd2af6091377450c3a8f4930fcb7dea89d428b38d2e4c2ec1df9536988b2168c46e3bd3d2f3b967dd385840881aecdaadbbf04b872c002894becc47b7a38b4f6587cd87f13678481ea0e584608476946ec4ecbdcf52dbc13fae9079d4da053b93b11133a22f0b3bed3fdad343ed74d74c67235cadf6ae3a5689b83c78014e373c044af6d3e981cd41e6f80a689c05f12c3bcb649a54dc3a04324c823e0b70e9cd627f5bf2c46643310a38b0c5b60be59948ac9ae23cef20d70dfc010b0cf7d632c3ccd5e2b0d2b0d7506439ba0fae844582a28274acecae6d3d639a5dc0fac311a4b660fb9cae3a94eb8d4e6403894d2cf75798dee02c6072e00f0a1a41ceb41005b68fc254708e3aaea3739aa8763ee88a744828ff196408ee28bd640bc3f5c529e3242bb2034f261d94e923223fe6277cc9c1339fb4b97b4f6c84b53eba441e7027120510b7cddcd6c3b4d683ef0577b016001c94636d2df12f113fed2f2d29eeec1b255c7112f58028f133e7f0d92e95261af09ca219b4cd8aa584f83191b60f9e700983ccd8f0f4f83ecc0f69eb18c03464d02da09dfb9914f45aa064891930f8bc997afd39f9b958c309bd86fd816fb73c587d16a021e69f3f03c3711565e9f2b5bd0a6b2b541f8a1fc8f04dd481030b723bceec675e4d1da03fc703002a8e95881271d24da820165535c44d341b4669de64d899c8aa0ceb23bb8b14ed31e1b2c9af8ab4e54c55e3d8ffcd4e064a621906c27779384a740c98658bba00a73fa9d685609f6e8e630a340be1fb5a2d4eaa7ce981e2838fb8713cd633695653372ef556124a1332d605d39a048170456541ac3c479d830a8f879746dcc2a46ce09b4783090881e4257b49740e2967e9010984b936db7fb685f917b30af228cb20cd0d2c5ac48f78052420666f67fc5d544d80aafa22a63614a7054f39b9e1631b806ab9a9ddb202fc85ed4425f66ee45cf260fa2376a417e3f65c643be1b6b55cfa3ab95e0138df84e4ef65699bdfeeaedacd0d2d50d324545137793dfb455de0b437a49c8e3dbec35668ff5cac94feb49e8eca8b5ada541652b330a02b6b13ed3dd2980898b256e7f0ebdba026c0bdd7ea8af4d288c9ad81dcabd2fe1c47b0408ad1299f6786bc0a16652eccc989f3b0c669bce274d6a2c4681088a1e559327469d512eafe49446445bf0c2f091c866a2b6804187e2ccd6f251ff7ad195ff88681bd5c610327962fbae528ca5a13d6b393b7d5dbb021f2eec2d13d54fd6f459d9f3db972aa2dcba457b218eb2c96d1bc08411bf83e1d48e90ef7e8ea33069bbd07accd9c8a7353d64419dd65e0154e4a537f6144fc10b6ea89e0fdb8f5dcd95ad4d71675f326a37dbf1ed9b2f1e1d1329557b88f9be43c344634df9cddbe04dc9c5b5b0f85722ad2fd04ffecbf306eeb38d64f11a4fb1cf68a748b62e3c04503a4930aba92577c552fa7a9b4c0c5d6558c6b7c5eab357c2095d20aefe5681841e9468461fa412c9d9d0034d274b2f6e4d6a59f2e8de76819d2fd5f1bccb05daca480a9ef31a6ef932768202bdf6e8857622f6df1f977ee1c533e1e70b1bfd8b919c3a3517fa5dc3f2ed99b4dc0dba145be037007988311a59062cc8815b6ffdbd834cc4f0882d16615273cd82fd9a72274858377095a0fe0d05c68b5216a17e1bc74753d4880c96aa57f1eccab31c0a6574275182c5c3a82bc1ded75ba517280623ddcb4dd63e2a88d7317916b26381b449c2554757cc5a15f2d3b28b16d5523154eb73f210ff681c4a013999637233415b72080321e34f41878a6f621e10affd5cbd0ded57b12110fda44da890943ccf697d123ecfa4add802f541bd0210a7b4ebcc2e72d7fe8c14b9b3bd03418642b4a9e4e4866cd762853e5a72e560ada8cb1397fc37541f74a21bc89d9f071f8a37575561b89b676b2e41143be31f962b04acc1c91e4ae8e76292151ba390ce643917e98a9c2461f2fd80852968630e2e67f6ccada800c00fca8e278105f5edb5b1ee297d109a29e8df8b5536c8250dd47b8e86e604ad4d57ac285f2bc4221b9abc7151d35bf8539714081ddfd42e9edb03fccacceac97beb9361452cb4f8765d8b543eafee915fd640d26f6241bb591ed51f38951e5fdcfdede1a52ac0b134aacc1bd22a7f5972f79055281b265d61913d38fdd40bd6fa9c690349832fbfd7d8b44e444d8bbc3876f87bf0f847d9b2333ca2963397d205290786597dd1d4f62cfef11db879284d404ee53f9bec89a62f70b31914c07e5b81a6debea41be1d4408a933c5bbdc64431ff676c741261b6de2ac7f7b8cc7c5f0d60e6b21650c61e0bd4b4abb749d8fd079a47a4d2d40717a7727d63588b71512b8ef2620c4704d18353ad29121626954cfeac3cb87d2c86caa4095ccddff856faab563ca4562420002cfa1b13929550094de160ee040fa8f5bfacc7d4a4bef0e609a1192c61707fd48cb71d95cd4dd982461c44edbe909c14b5e0dce8415efdc502490d0edc68a672b78e0f61d3f1456830db157adfe77b0c9ed91b95a548da7f6889c748f069ddccc70b9e6e4c55bc55c0b811c841d4d488cfae94c1062b10a70ce9d48cc57f5d922414aa7127f0b6cd5652e2c1f332dfc4b91c2b0bcd9fbc995978ac7756b67ba0542f48c6d4b6df341510ed4684e64d92dcb30e45a1caec6a2d3bea2c1e9dbe9f6b73e929d8bd500ed221ba0a3e7c35277979d684c4a88d78a9e67c451020a41dfe6ad566de050028f4fc64110f1b264f5d1f956a0dd57f1b5de3db55c3fe0673ffe420474cd47e55388898b6d15f99d168b1190fcce852d8766c789b66cc04b28b8cafb39bc8913d19b708e7f7aea2637763435306bbcb339dec09d8619b22e2f8f058c0973ecfb3a49df3351cd61fcc89289aad4d4d59b8185d65da9582c593e07156ce4f92696e968cee9a8baca90c7cc703725ea756659fd7ce32219bf65fecc77c6463aca2c84326399cf6c0caa682aa79cd73b2de81746f35c30f3e33662d347cd726ffddc8f5a326061e7631c00be4568921758531cabe934c5d3b5fdfe8494eb91d76eca0298046914591b280d3f557221db7e7eb31685aa8d44f94ea482ca7ca83c0abc4e745fc4caeaf7f3586759a722d49fafa50e63561662e4f0e418ddd565c9fe5bd5971c861899db7b099a07256b5b0c73d41179d6eebd3f82e8872dbcbc35204d7f5d3cc2079dc113a04f07d73fd7ca7af55b0d159f87b98523cc55a597c2051276dcec1019cbf9028ffe268fcbb912934ed5d41f1330b30e297c6297ec6afa9a40ef16f9e4d7289f93ce6ad3d75b0fefe844abce27963f49726ae68e992e8016816bbd3547e7aff1f8f04f91fdeafccd1170b35e0f963aa69f30ee62d69e8207f878d78e3743469a2c5fb588b06e5b93500e77989fc6e08a4f9a497d354216f374ae0d2e3faf92071ab86de6b6433547bfc0e343f7ea03931655fe4e550c9569158b3cb97a7d4c9aebfc80cb3c42875a836e56c008c8ec36064db927d1d7ffb3ab490c6ddfc6393495da50df0f3c17147","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8e8ac270c77b1af286a2c82320642de3"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
