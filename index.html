<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13fe47478053531f2c63fbebc6ff314c83621142528d247e5de98c61ac3b3f351d8c1a1e25f83d42b7d53f7696042ae26028fcc2e48b78b151d727e92f3e318b036358b1c0209739de3aa4187766d397a0a9daf444215e019fddeac0e7bbf8a3ff6fbe5a2e2a6c1000b532d7c130a9cad68d400fd67d7a430777225d08bc82ca280433d870feb8aa49833ecadfb99906a2b61c8a63fb07723eb58557b9277802c6e3dfdd1a5d4446c349c963d6b9cebb85a31ce0268d4a3d3d63e95ff141f84264bd618c6012e04b3cd611056abaf46c729725b769db619420c8beffc793259d6b9a5e040d8d8247f52be20b99da7674ed41c7505446106ce4b4e6258828e2fd4d1d9abaac0d84c5e6439091800ed7c80c733a436595d3715240c51a531d3557ce6168b174d47d0673e86b26445c9c0eca27049cfface95ff682aecf0d5ea30cb47dd33bfd7538c8d0bb822037d46a971ccaa41a8877b970b64befcfa0171c6794cabe3265c307e54f45aa948a3db9e8e0403f79fe074f17cd7f4ad6805ead4321f8621be61f0daeb01661072ce5a48c0925341d1e43a880929c4dbac4e53a64c65a0d8a5631c04b83f6d8651ff7134e768df487f3fca0f5ddc74aed280fbfeedc8447bec3e5eb5d5df67fd5cd7b11dd0bfb29661c1ec3bc0297957f41d950494ea6d7fb1310d6cd580db4b234f5487811127139b3c7f65bd3959b31d962ceb9f2e8ebd7f12654519ad37bcd849da14a17c717ba4adf8752c290e5d5d98bfbc64e26ce1ef8d391570b2dc00ded0ab6a8613d009aa111ba529c93c5f11fee9352a1edc3a0ed2630a04544f25feabfbfa12c97f44be54d3d5f726cc667476ad25185aa5f5412a7aebdea9c68d504f7b0030f72a5e3c3521b858fe173adcca9fb5a29a372b36f755ea206c9f58bc6bfb8dda2522010cd6a65837f30f7509a6a95400aee0f3849a984e75c3782313fcba0fb971da5d80c0b73017889711de28a0f07a950288c73a6216f51d97297ee027fafc7663cdcae59e098ef18455c93e882ef8a0ae6bc65ae48cfd348ff381e4fc5557cec3747944cd45b25d45b7a2635f826e301f151605c01b57c0cf129b621285dcc995a87b7cec51f2ab314c54e195bd5d90fe19e16ced27c7fd3fb3f5d28c7c34611d25f5df7e48a4cabbb4b8467c8103bc3949cc1c7da8813a52bef3ba2dc8856ab3b1e3102bb9da7c2e9320d195914e7fb65f2f17bb22f91ef8d6180d7379fb0c8e0cd04e76bae370bd982b2d95744d2548cf1bddbfb1d99a18178e9d738c8319893538bfc537d163d42eabaf6e3b159d63db4f80fa6b7011ea31134a01d77319a54481e84bf8cb5a78be41a870a9c8c6139b8996b3068dec2eb198bf2817a40992c290aab5da05fa478fbb694087264116acb75895741657708ccdedaf1119cd6ab021db05fac18574284ceb2a64b708bbb15450e643627941fa294dd979eda9c662f279076b2fbea107e753c6483f2ee8a589a479d1effd33e39f70bb346e7dcbe709b9fb12237ccd33ec5e03cd68835c4c98a24304fca4707148a9dd1c3d53f949839888631193418e8726bbe1eb7b96012f85f34a77b52f360e50eed7052b8c96664af4d1c2c601fd10589b8bedca71a89449ea3f468ebb78b3ba7cf9caa692c0a519b5618df1751075b79f41bd4ab80118193a0b41d4c5cb48e56265340a9d9b9fcf2003a29505746d4e7859cb8075d3a3df4a9ede046309274b384bd11e3b37407db2d4a1de4696c8d1e351aab6210c19647ea3c14a5f7680284541133d05482533f8ea7497a62b15ca875e1d73de050f4c439a94fe57dbf34b2c5cb9ca2d6cfe588a3aafd31526149890baaec75e526ac9b7d2343931a7c09fb641df92cd031c9ec8bcac688d75576ea4c4d6ac38c660a7e5b665d20cdca47172799e83ecab96637feea5113e4b2bc36c2b89cf31703521a38cd4ad7bd41474311e8e06f56b2b1c52bea5093e32157ef579de095581543368b0b5e7cc056bbe52b5dc054cd52f571335c3539a9a3cf2a28f26ef09f922bc2d2e7e65d338c7d4507ce3e020dc0b2da99f2a231b2e304dffac9b994066ea0530f0d159682aeba694890309d2ca009f0e7c8fd27655c570e38660bd406a02a9540db28bc3ee50735c9de03d4d409404ec16a2b0f68d08df94a5730596999f9bfcf61579e04148776b9a9288a8f40c69b2ff474a2e94176ccf0d91ca8cc5c45b1096e1c633f6841b7db02fe26d46fd7bb87fb94ad361a20cbd9c27656f967c9e48e90857f88be93c3ced5fe96fd6252face8807fffb147a38146e87652ad41b1f40a011025ca18c2ef4a97273f5acc9d76f9d2451f421c3b14bf5084cab5024d4d0d68181c96a4b35f4e9c949b6b398da8e9872480c2f524c140176de00dba4a4cecd87ad33455221196a6a5afdb6394a621fbb5acc4e8c0f529c7d4d9dd8f97abfc83116faf43f2b6d1ff1ebbd8549eee178f55d22036fc532bcaeea5de532c6eedb5245591b51ccbda73eb44762bc7b6586dc57d13350fc346927ada0026936594500f747e2455e7bd14fa39cf00ce5411fadb6bd82fb997c0764dfbfefc97da320be43f80a521b8ac6f3437d4bdf3c0c1bd449254b812914abab0d12474236e77c0c83f4c0e0f5049a0b9513548b1537e825f2458cc06d0e186af459009869cd7d65d2d92a7ec84e2baceaf5903093100896c13cc5c1631cf0c1facdb9a7664aadfca7cb4e823dc3edc13c8e34655f67b82da0a66a2011ba83deac0dbd0d74d18b9934da9fd5d2a3d3aaf2d0a88822f5358a4f88a12239fe109efbf50ff99783e9383442b26be63734ea6bbffd1eb820f864efb5f22fd924abc1806ab686a0ea678732f9a6e9c8dc3f94d991052d42668ef8a189d49152d7913ba024b2410b1c78e3781e92e2584b8a9f545a38a0808aed1178c7a0e4dfc49baa9435238e8c4c4ee98b88e1f23b3f2eb04fddd7f31d58a5ab0013ab5108f231a77956ed9f6af4ebdd780268715504c9db603bf1fcf0e28f9435a09aa1435bca06baab9836cf35f1cbfb762e7891a4021e215bba2cb7930a581841413f4e0d53d88323b893fc31dcef592b15ad6bfaab7570f877cd20d76a5ca3fda3e2fca6ff20ecc7ca5dc2ccd497fdb4a1fea875b6c236b8dabe83a982a4c3305d96171a38e4753e3d70fbc60238020c84ee56a6e3fa0cab3792cb2ed7373c1bffb5024acba0a4ea60c1e846c88ce1e9a3b3afee923e0b1b5b85599cb19cfd6154ffb5fad3a2ec8ff5467ecaf75c7cbef1ac61a5d2ff12e90012523bb29e1d4c193ba6ac62d463a413b9ffe6e8abcd2817756a6e49d6d588a8b7646672da6736cbff476c4ea7b642e1e0bd36016e45d734e7adc73fa399d15e451a8dc1a4526ee08550ffdcf1620a809da9f20af507e52a283887c1b4eea25731cbc11a614663422754fa5baf82d67d86b30d18c3feb1ef102f6cb81b8caf46ade3451b0cc2041c96e86004d781fa402450d9b4eee9bd8a229a10a1f3c5bea659ad9bb6a4628e40729484a5de0907d94c7f4e37350893b255ba50c527224adf0b7a1edf3f314000a97614212621e4b45704679e046296a00e45314ec8f41b601a577244753269fe3a0d43d23df3faef3e47db46687634ccec623466a1bc15f69c666a7bea5c9367b97afa61aa5a4b0cc9a0e5c0ad1b5918d8a62f4ddb710f7f305bcc9ea091be179daf8bfac706c017ef99771f6fbe40f7ac6df8db8eaf422dad13782427a7d5d23d4ddac8ca306a4c3e2cbd219b94f7efc18e39f352e7821430bd73c8ad9e905474f7db403783879c9f4516b64446e48bbc4310429cd151f26a9b00700c18c92e26fd9383f25ff26a37eacec64a94c57a18ace2e0ae9c0d00451a36db10f8beda68f6f818f47d15cbd2d65f9c5b48dce225e375fbd46e7404656127810b626fcb69737e6a0ec95477f2ba7f6b18d0f83c25ff527cb2b021b7a162bccfd2e44a44458f371d21f9a33bea47fac6e37a642feb6683eadb5bf7aa95834f1d9302a384080dfabdb474c8b36a44fd4925c5ae33a758433ce489288286147c9610c99f5ce5bf89c37c9af0e105334f691871ebab8c2cef0332c762d6c425b2d0e9fab47d5ceb0ddb9f7626b584f1fc680f3fef37f18865658c4fee068c6dc1957cd1e10ad27e80e5671c1765878d5324821399f439dba8fd57c3290fb2b579d0ef1e529a28a6c0b3da85766e70c65389a968e71823836f550c551b5be1b81ed26768bfdc842babee1e1708f5b42c4b7baad68928aa7e251faeea3765beb7a193d2b3795d1bafc1e33d7181d79f8722a31303abedb32617db7d8140dabd5a6b36a50fc52638b71b4346cc69e28e2ca5c1fb90676c873cb7321eba5411ff8f35a11f18638a407044955379557d6be3c06cc38f6d4974de954a4cbd96bcdecff66bda1c2b4fd900df732a53e1e17f49096b94e227566a3c10e8e699b12a66d33268543e58def29591c13cc87e86163145793ef2be8337fc3f2a00f9765690d39235a3f112b3e1333f5e113c779f37ca173742e1335f81d09f71b9cad80fc39b68553099eb015bcedaafebd9f9ee98163f5fcb6464e1defd9292f5aa44e50a950fd9152aa82e3b6f3314ae3c57710b157294da47884c563e89d9db87dacd5aa91dc81315a50eb1813f9414cac7a581dd31b8d8bc6b48a48926fc798a0eb2a61196f465e6a9d60eaf4b24ea024416022accceb9bf6700a7d4902d868bb4f3adb34fbdaaa78e669d65032de8538d3b5f2772bcf7917cb29645de168f9cc71a04b3890e7898e742ce1e6905f61a1dcf7d3a4c29fecbd399f6c6fd3f7804da7e9e5849aed40299625dfd8d12d779013e343894ba98b6ccb9c52d7e7f3104bb5e726eeb278298a07538bdb6f8b2975183ec2bedc599948a8d75cf0bb0eb1fc80ac893cb6dfe96d012c3d962fa6206fd3448c149e2678d2555387358e68cba78baa9c719f9523c3e432e63a441d66a89f4e39a1a4856cf97cf94602f3bc6b41d73514396a8abdf5a3e1cd57479ff183b6964549dbcb4652c1f18cf72913b08dccceff2d9342ad73a7fd6a595b9e1310a82e0017cfc686d0b1d43ecd1c147574bd2d66b3fa2799be21a12f090b5d6151f4b44fbc8c097b755ab887a9adb9c51b967cf7a51c2c69bc5285e249bd9e35592aa709f995221e0f2fcd22ab5c48b49e7a7f300917f22f67e959919c0aef19f61e85a170778973ddfd79424dee45d127e8fea9787679ad9e96ae454aa17e8ce6f32b2d1a83fcb3c189c92d6a403a68a09205c5a04d9a8153987cab96fd2586c74a424533c55902274e90ac6c01d2b02ad861cfe9ac25bc3871dbadfbc802784d66ce02388bdf1458b90c03d9a4c479795163d4e98d9b1867aa308cd9ccf3cf3036145ce9e61fbf40d2bc8f0cd3cdc14153c8df784fd3f3067eb4a1edc111d4786a675f0cf3473208bc3074dd342871e12ac740855697510216aae2e601668c7346f178f39afc76f457e998d37db4e9fcdd4e562965e11a78f80fba62374d440b2422069a34d007544dca6abc63b952f04a6948c4a59b0c9d4d8e063f3d424ee39ce1185c2cb2064a2687bdbda9037863b3371acc99f055b5d7a0547733b900270d231b73f34eb8fdaf5d742acfa146899bd6da70e1c16dd63613cf62f68d4ab9cb724d34911ebf1a76069822479e0e100b6aba04259e1856a262ec0805c5f0bfabe598d92e67de3369148952551c6aa785d5446442e0e131410a9cacc7fb5fcf34b7f53c1fa8220fb169e5e5726ec689cd92782b10aae4427e132039c1754fc55a65e325ccfb78c6a09dbd78dbb812ebe62a9802111394cd64a5dce84887284c5cae663dfd19248654ce463e4d9fb6de4ec8f980dc3814bb251030f392f2087e310e9562fb7b47e7f6b811aaa580654369c5be75818f5c5822698816c6cf63530182444e3290b538499197e0eb108934707662e934759b6ba82cd1294d8bf0fddfd8d889c13f5e22efe1147cc192bce1a416f8b393716a1f8f4687c6b6749cc1d6450b69f4a3a3168b9ab963660b7f846939869b911d4c4626ede5b163cce0c4bb971ebced027d86445ed8fef2a4abbd1f5739f5cc0d87c0f3d1d8adee6dd6df382a0b1daa607fc9956419f04d419ccac466e82f1613fa2efcf537b1a4079bb0467b3f3ae9ccf0a99339ee4db80e52a3d5bc14f17a06915e38a9bafd5f3aad97f3b80255cfd11d20dd0c3ba2f6256c9d585c24df4d7adc9917078ac145e5bb3b59c9c3d9e51b7402d3572361dc1fd430f8ca49ef4b31eee1a600c5ea5477e7396dfd42ea4d2bc5834c574bc5b76c27ea031b0cbcbb48cb9f8492a3392f8a65318efcbfe4c2af36736a32d44fc3eb2df47154e5d73a186df9ceafeedb01ae9e12f7679badab7f1ff58daa08f7c09cc48f7fa9e7a6e26e6633f91d4d01bd56ca30a847547aa570a767eaa1b5741923e8770ff349af0904470e507c60f1092709d545d411303ca87549a14bf0343c03b8d1216cb384ecee0e9d59d08b441c581bad2bb1549d048909114848c6abeba88e8dc25865ed757f96f3661ba708ddb1b181759ac3e94f09e4e170ad3ff622810d780b852c58b8a781bba3ae6f1fdf938537a8338a051df4f75cac43c87ed5c9d44f60b355efcd81fd1766fc8f2253804efa9520336a74454da782cdb515f6f0cbcf900fee030b18a1dcef57c21e5a36f738676cbd77dd300def10091d134bdadcafc313ce85934bac40b4fd91ef5c089db2b5ec55c6611729ba53b435633828105482e4c662e85b3ca8cd1ba127e4d84522b06c0a054b9c1e97c9d3e04fe84f34edf76562c5cc51b42d1daf4f2d2932b3ba7fac36080026dd44190b3900df869270f9b1b29bbaf7f8b8145b1111c4c5279bb8f6a08557f46720f2ce7e14f0720f4d869eeb2875993640dcfbbbee1db5f51d052b90fb337a670ea5f8c4834b93d5c3870dee407aa4455d80253b5acd73ba114020c0e3889fba6760dd39928ebf2a136617ea12b8f1c3cf83be280abd8e1c0b9080fec1e9c830bd4310ed73c54767b2a2cffddb591320a835eb4722a835d15b61ac8705f4bb6a19e1d1831962abc3e987cdcddd244339692a6faedede5b0f4af55ae78eb48c39e078679c411196684060729b0157957b84bcc4acba037ba9ea715d4b32bcae3975a7026805548b415860fbe010e66a94a24b3e35142824d37ad826a8c54c475ec0af37bf0f64676e1d4f25151cedffca88adc87d44d3509ef1e4b4ef019fee26b2d096cb8680a1205ee5fc4e1dad1a02990d984779a1839cbafce5ad6509356d90261d43bcdb66e8a3addeccabfef33423590b2b4a4dc76fc7fd42c7dc07e12b0acfd34bd7bd2f82ad5246bf751c8bcf15e0d7f433cf0b4a0444f268c171ae3895c0c30355bdc021a44a3583248a042170af75e8369052421060d38137ed02e8dc1b5e688f0c05e39dc1c227ef83ad398fcd3048853ac8ed2a3664bc8770d3de2e0102aeeb5713661a8d175ca9690b2df8dd36ff0eda64f08c09cb32e64fc93283a00c22fb370a7ecbdcd75312bd97a31dca75c4721d8aaafcee5348f0bd48fe2887c47792c24a340a5040f8bf94d0e3811ebb7acc3626aa7ff63caf5946e08e3f89240d1dfe402a1274e1eb6429d1add010e64f9e5a301ee6bf5eb5f6923239aa2c930b0aaa2b26c52e3f62cd681e1018b05a9dfe75c0fca9a75e9649505f69fe46500f5f930fdfb0433d15b3bda02af5b67b09f2fd6f6802e10399e78dc17d4d20ad49d53554afa792e682728fd1711901ee3339ef941a3d01899d66f9ffecde547ab823de7665d680e4283691404e5b618bcc040d9adec20e59b2af3b370d67b571849b9f371f8d76c1785928345ac8c64eae600da0c618dc818e575b181865cf598925538cbff86b91f3bd5c3881b914911765d186df1de6b5c045e36e2148dbed378eb330d3fd996ffa2d57ba48c623c3bb2c22ba64dabb00958f64e35cf64b3f4757ef089fdde402d5b395ac3ddb5f77a9e3804d39891160fdab222c0abae1e0daafd07d709b854b211f4cbfc2bb528bb1f92e9759571bad1545ebf9d779f27579a6c04c7342cd7d0e7c13127f57277bb3ce2ce48846766da90147fd158a58a6496b348c664141b228a3f296f426ceedef13124a8b7d8b52a2d68c11881554212c49932df2371afbbfff5f8f5abb57268f4fcc356e07914591fefa9bd05cbbba853711d9e158a89dd62fd976ba325c76140f0f830960c03d5ca0c745b74deca6a215004c0ae40ca370cfcecf548f6a9d367a090d11ecc6fc00320310a2b476aff9a4c1142947136fca6b12c926bf0cd6b153b8538832f0999bd773e2ac3b5551634cd25eb591e5897745671548e1eb5da5551e8a90f2f481037d04b0461bec007e8a8c63303ec8081bb650a6b235f507c90b3e93e237db66d27f2f7072f5ea83e1ebf8b45ee6947ff647e79606b12fee9815c5d8d6f3dbe734d94be525bc7ea3be9a30cfe03cc78bc4613571a5e1a36a3a148243f28b17e055d03a86a560d8882be3125c9799132168ded4b26aa964048bbb1160124a182577c89705a858aaa07eb9b11fb444e9a60c4fb5727fdf78eab184e5b20ff0726e754f149320b228122be344273e3f01013cf07cb4c35cb79372eeb053f5cee1b36b9dab322bf62bc09d5703bec563de916135bed0dc8e46943bf3e8e90c2e9de64bef82cb22b871408bd55293f4ea7f55d54ffdaf87183c91fa758b38159ec5613fea738a34f419e17bb49af009b8d5755c357e2141e0ebfbefb7e5e5c08d33ce86c179a621fe164d65e10f8d9210e43f6c53a0e6e984ebdb4bc5742094f1150a9ea9ef2325377d3db821a5c9208821c23f745d6e5a3ec97fa9134b5719f422b9f29f911c5b5a1ff2c85d4f53ed7b22a77ca8aa545ae77cc7050fe46334a1e467dd06735308ef65b48ad2f973f09d229dd22858e2d02423b72d4f854a119a8b2887366291329b73deb16d85b7c34efcc4e8566c7846ba040eb8ba051ecbccc90d1051469a30fc2add022c7cff0b80a6f32ff0cc7fee86b5aed7032127d82b5b1ccba839cae3327d8ae40f5aedf7c89c3fcb0cdb2fd264ee2e1348c608be3cfd51f779c3820f24a137c6b402d8f109211440d97ac2ff163c1007d0347f1e7273017792da56a5c3c3cbbaa4999fc87ab46f184a0a17aa33cbca5e2471f2c7bd28aca0755ae4303bca2795d5f06b4ba65a16b6156373e6564453114dccef58a295fa1cefbe69f937d690a313c1f7a6eb47859c4d85b9eaa63e17290664f3dba3d965e6fdf3b7b6916539a95ca7cdcbd2eb400c58386d1be4db61ad65a483566f8579057bc75b6cdd4dc0a4ec75860566a29bc77e4e171bedce5b3a977f1518b0e7dafe8c2d8ae9ffc6da7535774204062fd186227d94baefe1beaff8cbefce7e6b3832e0cb1f65e7d3bbb335780e271e4396245709a5ffae95339004abfddd49bfb9e4d5c92c22f61c23da4d3d2634f1352e4c67765f90d8db8dc7307a6db4f4234e40821c926922cfc136563f442fd03f688b4b368c8cce2d6709a3cdbfb3ee56c196c613a89ecf9e6d5d9b581ac145e309cf35a00bc69b0e2e560f1ebbf7c35420788dc41afd0760e2769ac2e22edf2b6c05c83cbd76b9276261bc84f09e64a722f9748dd8f446e9dce230a8e67c1e66ff90fc8840729d042698ad8e891bc51dccb865d1cd27f5687fe298262da0bcf4334a1ead318f566300eef3fb57f80effde23ba4bd73cee278125b74f2c6a5b17defe4e4510c38392068116b430b911154ad98c36b07cccd9d4af473c1f7ade0442b2d473cbe3f65976190875fe104592ea4803ec4f06c1fa444cd780c0575a6126015ec78792c357d670c7ccb2e7dcc029824a8e83c7e4e595d6fe7af77a35d0f490f8cfffa87a9d54c517e43be94abac5acf01076729a2b255a1a5386b3d512b164f83f0852bc9156fa4065fd0c3e2b241396b3b23b0f383135fd456321547e84dedc2f530413de77247ff205497d075e557fddb90b8f2cc1fd8a5e30b9abdbd72acdee19762417cbe9e2b363ec738d59ea68e143c00c24283f35da645b96b78d42452364c52a5b52d72b82f03371ff18dc8c9e5bb0a3e46bd1c5e4782bdec3a6adec92c10600ad82d5d5254670444ebda3709ab40e025c6b4bf8fca1819cf8aa2f04779ef2dcd58c98a1cd78c2900343501f132f317c4f695d39b25f52d3b2996ed2bb4c80fd98b2a6d4ddeccbb40a8e4689937737a85c8528a1a5091ae07996663f636ab4a593ba719a1b39e219ef6fb4ca5558185faf55f55ba781d93d5a325f587469071aec7354df59c641029fb93572e709bc5cca67dbf36511b37950838f02d0b34e34b848707587b089a36fca97d41a59d4ca82df4a0f55503a70282a140360c08635143deaed10258054b7e50a293c4d505d9e5812f07f3c1a414c5c3ec168beb109221f37768b0a50cd782053b8c6f05bb1989b0bec5919a475b6d44d40ad629d9fc3a9388c2d8d96eacb34fd9925712fc61b9f4488179091ff12284ed904889fd4269e79810e50002bda43b2c558ef7604c7fdf6dee7de3f24331ff37504d4f3248e830ccb1c79ec81f77cde6fd2df1b54f334c37f633221906c20a85db131c4dfc69aa22884b3d976620cbcfca0c502c722ce56b6d779b769027cf9c81032a274e0dbdc3a5cdfa7b24e7ea9c919926492de4a992792bf45cc7328cbd5012302c1af8b39f6bc36a20798549f757e005de886f5188a46fd8b845421128b2dec334363731624c78c2dbc539b6da1323cbd9676611a243278708a4ba3dcc9c63db95bd807f9f2fe14362c4c2a0d2ec28f163ed5b5f8fa3379b5dc17c4fc60f6fbf6aa534cf85424884b1f0cd35051db01e0022badd3b9de40976b1351f85c4a1e42d0c93d7beec35367a9d837d6c525cb919fd10a6725422a73a1d57f02bfc0905e8e0168ea8dcedaeb4590418b9a1158feb8c07e6b9f21928e9107fcc3a805f3eb94064208e5ce3a480b86e9dd14a1924f58156e82e1c207285df48fc9910dcd4195f28bf7b045b34c71699b499fed8a8b5e632e109c8281ef9b56cdf62bc459038a97d5899dbb20eb4ebe72fd7cb1ac08cf9ebb2e0b27164d5b8bf5b0c4ba4c657279c2358e5ec8cede365aadd87b71bfc21ff7f7ab01e97de6866be38e83775529403aa29c634a9e40d4a6423e4a3ac606c10d943dcf2eab6fac2dc7fd65bedec9368db4c918f1fae842de88365944409ad4831a3e5771647ce817a03cae34148a52129662decfe4d1b40975a0ff0524d940954a945d527a9d6ace3a1e37dd723a6b02e067efffd57c83232c39c7a607f7f4a1f792bc10347670f254ab6db8a17cd2426b5e84129e56b72f785679f1ea91636073135f962ab54df070bd4172d2d8449c35d3227d7dd083e7d1985306bc4371b9cab97a16ceaea048c455cfdeeac3cc16487af3d4dc2e65ee06740c250139e1bcda209a569470926d98ff6701495ef1ae0886672bdfa7739fc59ab11c60b8e4d7a4518ab0fa91a85639b13c1b397361aef3fb267844b3126ee8f534dc0cd5fd5bf1b113bc4116d57eaea45c8ca36fabed778fdfc6925ac6d54d3bbd9ff90d36395786d585d3df020eb53db108474dd7d1e5b5a799c4d5f40ca0c311f93e6a92aca27855ef55ba82dbe219901a57e65f7bbe432313501b4af331921ed220a7d2b341fbfc62658947d28af5a21ad0cb58727155604dc0f05af5f783ae24430bb7be1687d7b788d805a697f1817062ff32ade38afa8554d81aa90473d2e19900f9fce0637324305bc578efbdf82ae588bd8ccf26956821b9f68e71ffaa90c595dffdb30c9031d619088c5de5a4236addb7d3990deed1eaf1539ac0b24a6156e80e9ffaada800480fafb0050e85189b7291fb9512e31a877430ac202b72d985397798f90f9edb3dddf3bb9af59d0c2ff8ecd54f0f073710e4790770dd8958fc50a8437865851a9a8246a26ed87346ceea1f3b838f035b74c70dd16ecf951d62df11ba9383edac56020b48125805c7d6ee95fecb061ee03770591b066090b42f7d2180185bf58dbcfafc1d3656b74b0155a0c1dc409760caf4903ff84df8db9848daa6a14d8798292442df80b22268d4e2d83c987332c010885ca2772daedb845bf938ff66649b7af2af93f2e1c76e9776fb2add7f9fd7827b282d1eb7ab3e769bd46c360e3b542dc0a75f18ca87e8b6ab023a3a2ae978034452b9ce337ca537e3c5b045e09dac564796b8c297c0fbf7f30dd7a594db3d3a9e64de9e5e771c083e6b1f3e5b55d9c223ee492f96c9bb5f9c3ff636bd7bc45b9020d4263a4bc757aa6b1faed71233d75656d6ae36b1b13bd5a78d967b7f0cc334e0823d8584a707b91b5fa2542ceb2562ba05e9ec503980b045a64971c68a39ad14675307ec0cebfba3947f0b5cea22bbbaf0219dfebec511e7a70ba37bd5eb1c41f973412baa74f5fa72447a3b5fbd4f6b0ccf6e14b35a0aa6be3b74bf96c5884cef919be341db2079d90978e0762b85bddc2c80896b300b622b449b0d0a040ca7b58636c6e97f9fda6da696795992450c5516eed129e57a4f0fee3b8b8d21f9eb3c77bb61264171f1632a962f4368bd64d5a6749e0e659301c73d3a7d4ca4ebc32f531ea1e01ab05761f753cde8b4ba65e3df602def38c6100d3e57e85596b0cfaabf0ad73e79ababc09834f8c9c1cc20634912033030b78df273a111cfabd16d6e8f1af15db8243df7c74fbbe04728361dbf36b79183db8a2190f6893c9daccacfa860e379ed63301fe32f8ffd709b594a1522311cc28524b465ff4aacb19cd1d5b0e0b631cc665b1d50951f0709c5afa67039b5a2e753258d8d8d66eecf2d8e8cc4efa23be90a1f00c0b938adb19d563d8da731428db54e74e8df99cca12a307f03a662bb3a0b6b461031a21ada3d37e1df219fa83b878252cf97e60e899d2fe3f8b2e241a62dea5c2a5351a3766ba9ed8cdc7ac99dfa74de0db3d54c7bc3a1eb88c5d4c46f4845d2190a365439b73cff8f6a669ba77200776c9af43d39ca05f88e4eef59044687022f175e323487318a986306146eb095b49c1d5e489cb09a574a69ccca364d8ee62c045f6b63d000c6efcf42ed0858f6b2bf94f9f1d4cebb1921e17ad91255e81b5507dd098efe8f15d130bfb85522dcc85c01f6fee2924ca31d1f9ba72924d1098955cb7d3ea02ea53afe885e3242f313d3e84e6f6ee814f610c5a0e241d032246fe04f9c7cd3e2a7c80d3608c5ddd245243219bbd8e701f4ba8b88379120813329bc60b76600746a1babfa12f2919137d77f55975c36bba61c1a5457a5106d50d32f0b29aaf3373a15b2ae14563120b89a34f40b88d6508aeea1a4860a16020ed8a31d00a36892396d3f4630d86aae24b3bf8c52c9314ec767f4b67e691e5bc2c054f361e61bd8198fed19b77cea977a8b3192dbaa1e34bd71d998c051e958ec1926976340c49c7030ac8a96d9b128e99142492761ec990a67dcb1db4006802b5f70d42d0f90facd2181d812741be20ba0e10f7e46dbb9bcb1527b0609c42e407a6cda4b60a3f7c2d6d519db5f8c5da76a50804869581474473a1969cb32ac6d353a9726eb1a2500d1e706a69341e409af13b82a11b781ac41e38b4cc673bed088ee9fc0225641ba4476fe43e6ad8497872002812e060beeeb2523caa5359888e323f976481a0c0f6fdb347c091a9530d2ea5b5ed0b022630c5a6a1d70c8b4a0129a52149dc07e9c5bb030cfb86b9d438f1247cabda54b551b593d69ed65f1582c1d19b50ae1242318d581147235f4a41fb7232764705b1a0bb2ba14140dcd4baf710c2498479bba05adcc87e323a84090b58a47cb72cecd23d03378e63c9a74af2384d8ddf74553f0f338ddd72989844de216a65fc4cf5b7927f071864e1f4351014bb38c2a8c53b28a9de32f446189a4e061eda9b4eee341bbcb05c4ce84c17279880289a5a06f2067e3ac6a5bf8041aa51aa28e59a9eb9a47eceeabea9b23633e6275873808706eb33f73e81a4276be9e5497415681944fc60f884238f07de37f8bab8bad7b0f0acd5cad47f1ba500c800a82ab7249cada443a92b75f6d0e1c0038757f3f1c624a8ee04ff5d8bb549388c5fb48300ef68430378b0e96fb75af7b4528201acba36377052dc27d93e5a3f3f19e60cc71fb427a81f0b4b73a63a4001d454797518d57b9a8a6d5f595a2cd147d96aae5e32c1c6a2f058ec4544e3a5bb3bbc2ec373d9f3aefc9aebbc704096460f9370dc9959ac47ba347685e7930a9a0036774f8badc2dab5600c69803a6cc9a35a67cb36fa53a0364e4a294841648ff3feefe5568aac4d9c2ef08d296a287934b1a656ff474edc0707d46c54cb5e25916641580b3ab7a1c502465854da056fefd32a2f5ca29a6d6c17b57ec8ebf302e9280c01165b2462795089c02540e864807843ad7955d2ce49435e3ba2a8261ca91eafa986cd72deab0dad41cc912623aee4190a25947e91a711eb2124da75ec7198a5ab3b43c258f396668ec6d121df4e4eb2bab8f90901deb949e7b789a8ca8e42c06403e89996ad82fa48dc6fde32ddaa7ab96dc39b5ac0f03af72833e37f6129458d8cd4c5a18700b50ede89363ed99c0e4805a871842878ee5944efd1f133cc7de9a066e224c8c2aec429addba6819cb1d39976299393f875a90d965520f448810a71af5658c305f3e0b3709f6c0fab3527b3ece57be55a51b25cbfe25f107fd7881ab85852db97cceaf1738e38e477b3bf162db33016a259df2d26444e268d026a68bab73650325c0366327d6518df8c185cf22f84ab4e0e3be336ab7b6a8d4cfecd9f45d4f7fbb7b491be70ec6cbd3b4dcd5da28e36506e378938cc5e3e731ab26e881c1b7ce7690f0c5220b6df50a15be7823f6b8f325a36cfb0d9503ce53fe3fb289c83671d3fbb454250e1dc999837fc146095b77097c127597b099c02bf76febb5573624d2aabdf7f35ba2e417698bbc236af8b907cb9a4428727b858f7dba67a10533f21ec53701f57078d894761f2383bc70103ab934d87278185535c7ac8afb16eda123a2a051fe28ea811e2b3fc47c751b959c618aaae4729ad92f1ed3e5faafc134fa24cdaef3acc42c847a81a24622b6f2051677cdde9e514e9d1b323f40d8029329fe5d2c884e24badd474a33a105b2d89dd6d4b351ea763276023bd47a1582945c1a3bbc020a0ada8970314b9e05502c91750e4d6abb3c30347a69ab52969b8969b23547770821cfc654eec37b2ae146f3382951f174cd3d5e5b5f4715de8d9d04db5b53da1a07448ce4c7caae5d32493a83b1195813a872b3214954e21cbd076766a86053d22974087f40c7d32504a9c6adfefe35fd6b514ea518627ae5390a04d33b78137e13f0fdd6f12a70fc6cf3c0069104ce0925eb9d4abe05811c45992133304e68f6afdb2b22085bc2b3a87cefcc4bece522015dc490fb5b6202285ec6b7ebf1438b49f3f0847d7f4bb4cb564d887f44d9e341cd19627ed724284878de628d47c3c545a26d9e9b746f1ff96a3d7cc562330b947aa2a9996df7d252f8a67bb41ae3d42f1631bf07eedefc40db7049235ff2f10686499011e44d9b2cd491a0ab264877b6a589c4d53b71a35747611bd81e1749c151558b8a5930ae04eeb4c025ef57ede3521288cd0d1d1da70ff619119b60a6fd0cbf4b1effe80142f41ec9001175c633389ab30cc10c634c05f55d4d40c7963c56fb915e62d6f4bde209fc59eac1f6168dcbf347ae41c0ffc3828ed4d2f77352cdf699389497fe78b752f73e146478857f2780881f52e33510782456cdd5e4ca60ee3686057dc876ac66b171819ced40719886e7a4cdec973f655caa75c792e13fdf2cf7d2c91667ebcafa497550b33955bfb096012229c62061ff1e40b7d9b7f40ba9092e2b4b4a11ee27cdc8e4e0c378c57d4354f709831105e263a10d7568b5a432daafea8915d2f8e565358ac1cf63ef8adb489f8be0f49b20bf041f980ee9a6807c262392a80fca030a715a15389748b5e4e92600f65ca21651f76f6083402798f8594f14b92ec32e84bc2ece8a5350284ee4a9133a4d404286bf1b4b6e40864a91a343b1b93e7e4bc1e04e53ba7d498bba75f323e17686529d19342f281ee579031a09fd9910f9ef3b0cbc3f0153a616446c2f51ea140ed73c23c97fd84ae0fd86770608c5656852750cd64325cafe4cb9de205a64b1170854bcba266ae3580286c490fe97892a44f26f67b4bbf5fee834efb5aff81d963374b8cf76b509cf34ca1c2c21557f00eba6e01a55e73487b769951a32e46d585b11a197c720ed43c297259c588de87f3a3f132cad0d671cee61f35b7f4299cd6e65a1ffcf54827246fb4a7cd1e41c60ebb4f6121e57e806449b53031cf66cd56454a9e21d72314cfffdf1bfa35355c94ab71a9804586ec317c928bf6062ff6adc7cc7b1388449d07e279f350cf367d60235c2794790cbbf34e5cd393c1e41c36627ba9b6f55b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c7924708fc72370b6beacb794dbb645f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
